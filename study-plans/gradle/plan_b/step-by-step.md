# Gradle Study - Plan B

Let's create a project from scratch:

```bash
$ cd simple-application
$ gradle init --type java-application --dsl kotlin
```

It will generate the structure of a new project under the specified directory. If we open the `settings.gradle.kts` file,
we will see that the root project is `simple-application`, and it includes a subproject called `app`.

If we open the `build.gradle.kts` file inside the app subproject, we will see its structure:
- In the `plugins` section, it defines that the subproject uses the `application` plugin, which is a core plugin that
facilitates the creation of JVM applications.
- In the repositories section, it defines that the subproject looks for dependencies in maven central to resolve them.
- In the dependencies section, it defines that the subproject needs JUnit Jupiter for tests, its platform launcher on
runtime and Guava to be used in the source code.
- In the java section, it applies a custom configuration to the java plugin (which comes with the application one).
- In the application section, it applies a custom configuration to the application plugin.
- The tasks.named section finds a reference to a task named "test", of type Test. It applies a configuration in a lazy
manner.

Let's now build the project:

```bash
$ ./gradlew build
```

We can see now that the app subproject includes a new directory called `build`. Inside of it, there is a bunch of files that
compose the built project, such as:
- classes: Contains all `.class` files generated after compilation.
- generated: Contains artifacts generated by projects, such as annotation processors. These files are also part of
compilation and runtime. We can use it to inspect code to understand what plugins and code processors are doing.
- install: Contains all necessary files to run our project, such as the startup script, the application jar and the
resolved dependencies jars.
- libs: Contains the primary build artifact of our project. This Jar is typically what we deploy to a server.
- scripts: Contains preconfigured startup scripts to run the application or to serve as a template. It's used to 
generate the final binary script under the install directory.

To run the project, gradle provides the run task, we can just execute:

```bash
$ ./gradlew run
```